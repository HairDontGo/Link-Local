# MySQL的存储引擎

## **什么是存储引擎？**

​	MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。

​	例如，如果你在研究大量的临时数据，你也许需要使用内存MySQL存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。

​	<u>这些不同的技术以及配套的相关功能在 MySQL中被称作**存储引擎(也称作表类型)**</u>。 MySQL默认配置了许多不同的存储引擎，可以预先设置或者在MySQL服务器中启用。你可以选择适用于服务器、数据库和表格的存储引擎，以便在选择如何存储你的信息、如何检索这些信息以及你需要你的数据结合什么性能和功能的时候为你提供最大的灵活性。

​	**关系数据库表**是用于存储和组织信息的数据结构，可以将表理解为由行和列组成的表格，类似于Excel的电子表格的形式。有的表简单，有的表复杂，有的表根本不用来存储任何长期的数据，有的表读取时非常快，但是插入数据时去很差；而我们在实际开发过程中，就可能需要各种各样的表，不同的表，就意味着存储不同类型的数据，数据的处理上也会存在着差异，那么。对于MySQL来说，它提供了很多种类型的存储引擎（或者说不通的表类型），我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。

---

在mysql客户端中，使用以下命令可以查看MySQL支持的引擎。

```mysql
show engines;
```

![image-20201218130707777](C:\Users\NPC\AppData\Roaming\Typora\typora-user-images\image-20201218130707777.png)

 ---

### **MyISAM**

 　　它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。
 		每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：

>·     .frm(存储表定义)
>
>·     MYD(MYData，存储数据)
>
>·     MYI(MYIndex，存储索引)

​	数据文件和索引文件可以放置在不同的目录，平均分配IO，获取更快的速度。要指定数据文件和索引文件的路径，需要在创建表的时候通过DATA DIRECTORY和INDEX DIRECTORY语句指定，文件路径需要使用绝对路径。
 　每个MyISAM表都有一个标志，服务器或myisamchk程序在检查MyISAM数据表时会对这个标志进行设置。MyISAM表还有一个标志用来表明该数据表在上次使用后是不是被正常的关闭了。如果服务器以为当机或崩溃，这个标志可以用来判断数据表是否需要检查和修复。如果想让这种检查自动进行，可以在启动服务器时使用--myisam-recover现象。这会让服务器在每次打开一个MyISAM数据表是自动检查数据表的标志并进行必要的修复处理。MyISAM类型的表可能会损坏，可以使用CHECK TABLE语句来检查MyISAM表的健康，并用REPAIR TABLE语句修复一个损坏到MyISAM表。

 　MyISAM的表还支持3种不同的存储格式：

>·     静态(固定长度)表
>
>·     动态表
>
>·     压缩表

　其中**静态表**是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。同时需要注意：在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。
 　**动态表**包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。
 　**压缩表**由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。 

 ---

### **InnoDB**

​	InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。我的电脑上安装的MySQL 5.6.13版，InnoDB就是作为默认的存储引擎。InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：

>1.更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。
> 2.事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。
> 3.自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
> 4.外键约束。MySQL支持外键的存储引擎只有InnoDB。
> 5.支持自动增加列AUTO_INCREMENT属性。

​	一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。

---

### **MEMORY**

​	使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。

一般在以下几种情况下使用Memory存储引擎：

>1.目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。
>
>2.如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。
>
>3.存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。

​	Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用<、>和>=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和<>的操作符中，不适合在<或>操作符中，也同样不适合用在order by子句中。

可以在表创建时利用USING子句指定要使用的版本。例如：

```mysql
create table users
 (
   id smallint unsigned not null auto_increment,
   username varchar(15) not null,
   pwd varchar(15) not null,
   index using hash (username),
   primary key (id)
 )engine=memory;
```

​	上述代码创建了一个表，在username字段上使用了HASH散列索引。下面的代码就创建一个表，使用BTREE索引。

```mysql
 create table users
 (
   id smallint unsigned not null auto_increment,
   username varchar(15) not null,
   pwd varchar(15) not null,
   index using btree (username),
   primary key (id)
 )engine=memory;

```

---

### **MERGE**

​	MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。Merge存储引擎的使用场景。

​	对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。

---

### **ARCHIVE**

​	Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。

### 分类优缺点:

>[MyISAM](https://baike.baidu.com/item/MyISAM)： 拥有较高的插入，查询速度，但不支持[事务](https://baike.baidu.com/item/事务)
>
>[InnoDB](https://baike.baidu.com/item/InnoDB) ：5.5版本后Mysql的默认数据库，事务型数据库的首选引擎，支持ACID事务，支持行级锁定
>
>[BDB](https://baike.baidu.com/item/BDB)： 源自Berkeley DB，事务型数据库的另一种选择，支持COMMIT和ROLLBACK等其他事务特性
>
>Memory ：所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在Mysql重新启动时丢失
>
>Merge ：将一定数量的MyISAM表联合而成一个整体，在超大规模数据存储时很有用
>
>Archive ：非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive拥有高效的插入速度，但其对查询的支持相对较差
>
>Federated： 将不同的Mysql服务器联合起来，逻辑上组成一个完整的数据库。非常适合[分布式应用](https://baike.baidu.com/item/分布式应用)
>
>Cluster/NDB ：高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用
>
>[CSV](https://baike.baidu.com/item/CSV)： 逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个.CSV文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV存储引擎不支持索引。
>
>BlackHole ：黑洞引擎，写入的任何数据都会消失，一般用于记录binlog做复制的中继
>
>另外，Mysql的存储引擎接口定义良好。有兴趣的开发者通过阅读文档编写自己的存储引擎。

## **关于存储引擎的一些问题**

### 1.如何查看服务器有哪些存储引擎可以使用？

 为确定你的MySQL服务器可以用哪些存储引擎，执行如下命令：

```mysql
 show engines;
```

 	这个命令就能搞定了。

### 2.如何选择合适的存储引擎？

> （1）选择标准可以分为：
> （2）是否需要支持事务；
> （3）是否需要使用热备；
> （4）崩溃恢复：能否接受崩溃；
> （5）是否需要外键支持；
> 然后按照标准，选择对应的存储引擎即可。

## **总结**

这篇文章总结了几种比较常用的存储引擎，对于实际的工作，需要根据具体的情况而定，结合实际的项目实例进行应用，才是最好的学习方法。

 转：http://blog.csdn.net/cymm_liu/article/details/45745431